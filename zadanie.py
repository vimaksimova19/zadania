# 10*cos(x) - 0.1*x^2 = 0
import math  # Подключаем модуль для математических операций

# Определение функций, связанных с уравнением 10*cos(x) - 0.1*x^2 = 0
def f(x):
    """
    Исходная функция, корни которой ищем.
    Для варианта 10: f(x) = 10*cos(x) - 0.1*x^2
    """
    return 10 * math.cos(x) - 0.1 * x ** 2

def df(x):
    """
    Производная функции f(x), необходимая для метода Ньютона.
    f'(x) = -10*sin(x) - 0.2*x
    """
    return -10 * math.sin(x) - 0.2 * x

def phi(x):
    """
    Итерационная функция для метода простой итерации.
    Получена из уравнения 10*cos(x) = 0.1*x^2  =>  cos(x) = 0.01*x^2  =>  x = arccos(0.01*x^2)
    """
    return math.acos(0.01 * x ** 2)

# Практическая №2: отделение корней и метод половинного деления

def separate_roots():
    """
    Задание 1: отделение корней графическим методом.
    Строим таблицу значений f(x) для x от 0 до 10 (шаг 1) и определяем интервалы,
    на которых функция меняет знак.
    """
    print("\n" + "="*70)
    print("Практическая №2 задание 1: отделение корней")
    print("="*70)
    print("Таблица значений функции f(x)=10cos(x)-0.1x^2")
    print("-"*70)
    print(f"{'x':<5} {'cos(x)':<10} {'10*cos(x)':<12} {'0.1*x^2':<10} {'f(x)':<12}")
    print("-"*70)

    intervals = []  # Список для записи интервалов, где f меняет знак
    prev_f = f(0)   # Значение в предыдущей точке
    for x in range(1, 11):  # от 1 до 10 включительно
        current_f = f(x)
        cos_x = math.cos(x)
        print(f"{x:<5} {cos_x:<10.4f} {10*cos_x:<12.4f} {0.1*x*x:<10.4f} {current_f:<12.4f}")

        # Если произведение значений разного знака – корень на [x-1, x]
        if prev_f * current_f < 0:
            intervals.append((x-1, x))
        prev_f = current_f

    print("-"*70)
    print("Интервалы, содержащие корни:")
    for interval in intervals:
        print(f"  [{interval[0]}, {interval[1]}]")
    print("Для дальнейших вычислений выберем первый корень – интервал [1.5, 1.55] (уточнённый).")
    print("="*70 + "\n")

def bisection_method(a, b, eps=1e-3, max_iter=100):
    """
    Задание 2: метод половинного деления.
    На вход подаётся интервал [a, b], на концах которого f(a) и f(b) имеют разные знаки.
    Функция выводит таблицу итераций и возвращает приближённое значение корня.
    """
    print("\n" + "="*70)
    print("Практическая №2 задание 2: метод половинного деления")
    print("="*70)
    print(f"Интервал: [{a}, {b}], требуемая точность: {eps}")
    print("-"*100)
    print(f"{'Итер':<4} {'a':<10} {'b':<10} {'c':<10} {'f(a)':<12} {'f(c)':<12} {'Знак f(c)':<10} {'Новый интервал':<25} {'Длина':<12}")
    print("-"*100)

    for i in range(max_iter):
        c = (a + b) / 2 # Середина отрезка
        fa = f(a)
        fc = f(c)
        # Определяем новый интервал по правилу знаков
        if fa * fc < 0:
            new_interval = f"[{a:.6f}; {c:.6f}]"
            b = c
        else:
            new_interval = f"[{c:.6f}; {b:.6f}]"
            a = c

        interval_len = b - a
        sign_fc = "+" if fc > 0 else "-" if fc < 0 else "0"

        print(f"{i+1:<4} {a:<10.6f} {b:<10.6f} {c:<10.6f} {fa:<12.6f} {fc:<12.6f} {sign_fc:<10} {new_interval:<25} {interval_len:<12.6f}")

        if interval_len < eps:
            root = (a + b) / 2
            print("-"*100)
            print(f"Достигнута требуемая точность: длина интервала = {interval_len:.6f} < {eps}")
            print(f"Приближённое значение корня: x = {root:.6f}")
            print("="*70 + "\n")
            return root

    # Если точность не достигнута за max_iter итераций
    root = (a + b) / 2
    print("-"*100)
    print(f"Максимальное число итераций ({max_iter}) превышено. Последнее приближение: x = {root:.6f}")
    print("="*70 + "\n")
    return root

# Практическая №3: метод итераций

def fixed_point_iteration(x0, eps=1e-3, max_iter=100):
    """
    Задание 1 практической №3: метод простой итерации.
    Уравнение преобразовано к виду x = phi(x), где phi(x) = arccos(0.01*x^2).
    Начальное приближение x0 должно быть выбрано вблизи корня.
    """
    print("\n" + "="*70)
    print("Практическая №3 задание1: метод простой итерации")
    print("="*70)
    print(f"Итерационная функция: phi(x) = arccos(0.01*x^2)")
    print(f"Начальное приближение: x0 = {x0}, точность: {eps}")
    print("-"*80)
    print(f"{'Итер':<4} {'x_n':<12} {'x_n^2':<12} {'t = 0.01*x_n^2':<16} {'x_{n+1}':<12} {'|x_{n+1}-x_n|':<14}")
    print("-"*80)

    x_prev = x0
    for i in range(max_iter):
        x_sq = x_prev ** 2
        t = 0.01 * x_sq
        x_next = math.acos(t)
        diff = abs(x_next - x_prev)

        print(f"{i+1:<4} {x_prev:<12.6f} {x_sq:<12.6f} {t:<16.6f} {x_next:<12.6f} {diff:<14.6f}")

        if diff < eps:
            print("-"*80)
            print(f"Сходимость достигнута: |x_{i+2} - x_{i+1}| = {diff:.6f} < {eps}")
            print(f"Приближённое значение корня: x = {x_next:.6f}")
            print("="*70 + "\n")
            return x_next

        x_prev = x_next

    print("-"*80)
    print(f"Максимальное число итераций ({max_iter}) превышено. Последнее приближение: x = {x_prev:.6f}")
    print("="*70 + "\n")
    return x_prev

# Практическая №4: методы хорд и касательных

def secant_method(x0, x1, eps=1e-3, max_iter=100):
    """
    Задание 2 практической №4: метод хорд (секущих).
    Используются два начальных приближения x0 и x1.
    """
    print("\n" + "="*70)
    print("Практическая№4 задание 2: метод хорд")
    print("="*70)
    print(f"Начальные приближения: x0 = {x0}, x1 = {x1}, точность: {eps}")
    print("-"*90)
    print(f"{'Итер':<4} {'x_{n-1}':<12} {'x_n':<12} {'f(x_{n-1})':<14} {'f(x_n)':<14} {'x_{n+1}':<12} {'|x_{n+1}-x_n|':<14}")
    print("-"*90)

    x_prev = x0
    x_curr = x1
    for i in range(max_iter):
        f_prev = f(x_prev)
        f_curr = f(x_curr)

        # Защита от деления на ноль
        if f_curr - f_prev == 0:
            print("Ошибка: деление на ноль (значения функции совпадают).")
            break

        x_next = x_curr - f_curr * (x_curr - x_prev) / (f_curr - f_prev)
        diff = abs(x_next - x_curr)

        print(f"{i+1:<4} {x_prev:<12.6f} {x_curr:<12.6f} {f_prev:<14.6f} {f_curr:<14.6f} {x_next:<12.6f} {diff:<14.6f}")

        if diff < eps:
            print("-"*90)
            print(f"Сходимость достигнута: |x_{i+2} - x_{i+1}| = {diff:.6f} < {eps}")
            print(f"Приближённое значение корня: x = {x_next:.6f}")
            print("="*70 + "\n")
            return x_next

        x_prev, x_curr = x_curr, x_next

    print("-"*90)
    print(f"Максимальное число итераций ({max_iter}) превышено. Последнее приближение: x = {x_curr:.6f}")
    print("="*70 + "\n")
    return x_curr

def newton_method(x0, eps=1e-3, max_iter=100):
    """
    Задание 3 практической №4: метод касательных (Ньютона).
    Используется производная функции для быстрого приближения к корню.
    """
    print("\n" + "="*70)
    print("Практическая №4 задание 3: метод касательных")
    print("="*70)
    print(f"Начальное приближение: x0 = {x0}, точность: {eps}")
    print("-"*80)
    print("{:<4} {:<12} {:<14} {:<14} {:<12} {:<14}".format(
    "Итер", "x_n", "f(x_n)", "f'(x_n)", "x_{n+1}", "|x_{n+1}-x_n|"
))
    print("-"*80)

    x = x0
    for i in range(max_iter):
        fx = f(x)
        dfx = df(x)

        if dfx == 0:
            print("Ошибка: производная равна нулю. Метод Ньютона не применим.")
            break

        x_next = x - fx / dfx
        diff = abs(x_next - x)

        print(f"{i+1:<4} {x:<12.6f} {fx:<14.6f} {dfx:<14.6f} {x_next:<12.6f} {diff:<14.6f}")

        if diff < eps:
            print("-"*80)
            print(f"Сходимость достигнута: |x_{i+2} - x_{i+1}| = {diff:.6f} < {eps}")
            print(f"Приближённое значение корня: x = {x_next:.6f}")
            print("="*70 + "\n")
            return x_next

        x = x_next

    print("-"*80)
    print(f"Максимальное число итераций ({max_iter}) превышено. Последнее приближение: x = {x:.6f}")
    print("="*70 + "\n")
    return x

#последовательный вызов всех методов
if __name__ == "__main__":
    # 1. Отделение корней
    separate_roots()

    # Задаём интервал для первого корня (после уточнения)
    a, b = 1.5, 1.55      # интервал, на концах которого f имеет разные знаки
    x0_iter = 1.5          # начальное приближение для метода итераций и Ньютона
    x0_sec, x1_sec = 1.5, 1.55  # начальные приближения для метода хорд
    eps = 1e-3

    # 2. Метод половинного деления
    root_bisect = bisection_method(a, b, eps)

    # 3. Метод простой итерации
    root_iter = fixed_point_iteration(x0_iter, eps)

    # 4. Метод хорд
    root_sec = secant_method(x0_sec, x1_sec, eps)

    # 5. Метод Ньютона
    root_newton = newton_method(x0_iter, eps)

    # Вывод итоговых результатов
    print("\n" + "="*70)
    print("Резултаты всех методов")
    print("="*70)
    print(f"Метод половинного деления: x = {root_bisect:.6f}")
    print(f"Метод простой итерации:    x = {root_iter:.6f}")
    print(f"Метод хорд:                x = {root_sec:.6f}")
    print(f"Метод Ньютона:             x = {root_newton:.6f}")
    print("="*70)